@file:Suppress("unused")

package dk.ufst.arch

import org.junit.Assert.fail


interface Step<Value, Action>

/**
 * Send an action to the stores reducer
 * assert function is run afterwards allowing you to perform asserts
 * against the state
 */
data class Send<Value, Action>(
    val action: Action,
    val assert: ((Value)->Unit)? = null
) : Step<Value, Action>

/**
 * Receive actions generated by effects
 * Actions can return effects which generate actions
 * These actions can be checked and asserted against in the verify function
 *
 */
data class Receive<Value, Action>(
   val verify: (List<Action>, Value)->Unit
) : Step<Value, Action>

/**
 * Clear the pending actions list in the test store.
 * used when you wan't to send and action but don't care about
 * verifying actions generated by side effects
 * (because you are testing that action in another test for instance)
 */
class Flush<Value, Action> : Step<Value, Action>

@Suppress("MemberVisibilityCanBePrivate")
class TestStore<Value, Action, Environment>(
    val env : Environment,
    initialValue : Value,
    val copyValue: (Value) -> Value,
    val reducer : ReducerFunc<Value, Action, Environment>
) {

    var value = initialValue
        private set

    private val executor: Executor = TestExecutor()

    private val pendingActions = mutableListOf<Action>()

    fun sendAction(action: Action) {
        reduce(action, value)
    }

    private fun reduce(action: Action, currentValue: Value,  assert: ((Value)->Unit)? = null) {
        val newValue = copyValue(currentValue)
        val effects = reducer(newValue, action, env)
        value = newValue
        // if given a function, run assert callback before we run the effects
        assert?.invoke(value)
        effects.forEach { effect ->
            // run effect on thread pool
            executor.execute {
                val act = effect()
                act?.let {
                    pendingActions.add(it)
                    sendAction(it) // send resulting action on main thread
                }
            }
        }
    }

    fun run(vararg steps: Step<Value, Action>) {
        pendingActions.clear()
        for(step in steps) {
            when(step) {
                is Send -> {
                    if(pendingActions.isNotEmpty()) {
                        fail("pending actions are unaccounted for!")
                        return
                    }
                    reduce(step.action, value, step.assert)
                }
                is Receive -> {
                    if(pendingActions.isEmpty()) {
                        fail("no pending actions generated at this point")
                        return
                    }
                    step.verify(pendingActions, value)
                    pendingActions.clear()
                }
                is Flush -> {
                    pendingActions.clear()
                }
            }
        }
    }
}

inline fun <reified Action>List<Any>.findClass() : Action? {
    forEach {
        if(it is Action)
            return it
    }
    return null
}